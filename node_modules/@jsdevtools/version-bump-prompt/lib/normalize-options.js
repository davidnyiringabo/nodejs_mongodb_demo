"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.normalizeOptions = void 0;
const globby = require("globby");
const globby_1 = require("globby");
const release_type_1 = require("./release-type");
/**
 * Converts raw VersionBumpOptions to a normalized and sanitized Options object.
 */
async function normalizeOptions(raw) {
    // Set the simple properties first
    let preid = typeof raw.preid === "string" ? raw.preid : "beta";
    let push = Boolean(raw.push);
    let all = Boolean(raw.all);
    let noVerify = Boolean(raw.noVerify);
    let cwd = raw.cwd || process.cwd();
    let ignoreScripts = Boolean(raw.ignoreScripts);
    let release;
    if (!raw.release || raw.release === "prompt") {
        release = { type: "prompt", preid };
    }
    else if (release_type_1.isReleaseType(raw.release)) {
        release = { type: raw.release, preid };
    }
    else {
        release = { type: "version", version: raw.release };
    }
    let tag;
    if (typeof raw.tag === "string") {
        tag = { name: raw.tag };
    }
    else if (raw.tag) {
        tag = { name: "v" };
    }
    // NOTE: This must come AFTER `tag` and `push`, because it relies on them
    let commit;
    if (typeof raw.commit === "string") {
        commit = { all, noVerify, message: raw.commit };
    }
    else if (raw.commit || tag || push) {
        commit = { all, noVerify, message: "release v" };
    }
    let files;
    if (Array.isArray(raw.files) && raw.files.length > 0) {
        files = await strictGlobMatches(raw.files, { cwd });
    }
    else {
        // Try to find these files by default.
        // If they don't exist, then they will NOT be included in the `files` array.
        files = await globby(["package.json", "package-lock.json"], { cwd });
    }
    let ui;
    if (raw.interface === false) {
        ui = { input: false, outut: false };
    }
    else if (raw.interface === true || !raw.interface) {
        ui = { input: process.stdin, output: process.stdout };
    }
    else {
        let { input, output, ...other } = raw.interface;
        if (input === true || (input !== false && !input)) {
            input = process.stdin;
        }
        if (output === true || (output !== false && !output)) {
            output = process.stdout;
        }
        ui = { input, output, ...other };
    }
    if (release.type === "prompt" && !(ui.input && ui.output)) {
        throw new Error("Cannot prompt for the version number because input or output has been disabled.");
    }
    return { release, commit, tag, push, files, cwd, interface: ui, ignoreScripts };
}
exports.normalizeOptions = normalizeOptions;
/**
 * Returns all files that match the given glob patterns.
 * An error is thrown if any pattern matches zero files.
 */
async function strictGlobMatches(files, options) {
    // Match all glob patterns simultaneously
    let matches = await Promise.all(files.map((file) => strictGlobMatch(file, options)));
    // Get all the unique files
    let matchedFiles = new Set();
    for (let match of matches) {
        for (let file of match) {
            matchedFiles.add(file);
        }
    }
    return [...matchedFiles];
}
/**
 * Returns all files that match the given glob pattern.
 * An error is thrown if the pattern matches zero files.
 */
async function strictGlobMatch(file, options) {
    let matches = await globby(file, options);
    if (matches.length === 0) {
        if (globby_1.hasMagic(file)) {
            throw new Error(`Could not find any files matching "${file}".`);
        }
        else {
            throw new Error(`Could not find file: ${file}.`);
        }
    }
    // Return files in a predictable order
    return matches.sort();
}
//# sourceMappingURL=normalize-options.js.map