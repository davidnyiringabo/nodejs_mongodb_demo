"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateFiles = void 0;
const path = require("path");
const fs_1 = require("./fs");
const manifest_1 = require("./manifest");
/**
 * Updates the version number in the specified files.
 */
async function updateFiles(operation) {
    let { files } = operation.options;
    for (let relPath of files) {
        let modified = await updateFile(relPath, operation);
        if (modified) {
            operation.update({
                event: "file updated" /* FileUpdated */,
                updatedFiles: operation.state.updatedFiles.concat(relPath),
            });
        }
        else {
            operation.update({
                event: "file skipped" /* FileSkipped */,
                skippedFiles: operation.state.skippedFiles.concat(relPath),
            });
        }
    }
    return operation;
}
exports.updateFiles = updateFiles;
/**
 * Updates the version number in the specified file.
 *
 * @returns - `true` if the file was actually modified
 */
async function updateFile(relPath, operation) {
    let name = path.basename(relPath).trim().toLowerCase();
    switch (name) {
        case "package.json":
        case "package-lock.json":
        case "bower.json":
        case "component.json":
            return updateManifestFile(relPath, operation);
        default:
            return updateTextFile(relPath, operation);
    }
}
/**
 * Updates the version number in the specified JSON manifest file.
 *
 * NOTE: Unlike text files, this is NOT a global find-and-replace.  It _specifically_ sets
 * the top-level `version` property.
 *
 * @returns - `true` if the file was actually modified
 */
async function updateManifestFile(relPath, operation) {
    let { cwd } = operation.options;
    let { newVersion } = operation.state;
    let modified = false;
    let file = await fs_1.readJsonFile(relPath, cwd);
    if (manifest_1.isManifest(file.data) && file.data.version !== newVersion) {
        file.data.version = newVersion;
        await fs_1.writeJsonFile(file);
        modified = true;
    }
    return modified;
}
/**
 * Updates all occurrences of the version number in the specified text file.
 *
 * @returns - `true` if the file was actually modified
 */
async function updateTextFile(relPath, operation) {
    let { cwd } = operation.options;
    let { oldVersion, newVersion } = operation.state;
    let modified = false;
    let file = await fs_1.readTextFile(relPath, cwd);
    // Only update the file if it contains at least one occurrence of the old version
    if (file.data.includes(oldVersion)) {
        // Escape all non-alphanumeric characters in the version
        let sanitizedVersion = oldVersion.replace(/(\W)/g, "\\$1");
        // Replace occurrences of the old version number that are surrounded by word boundaries.
        // This ensures that it matches "1.23.456" or "v1.23.456", but not "321.23.456".
        let replacePattern = new RegExp("(\\b|v)" + sanitizedVersion + "\\b", "g");
        file.data = file.data.replace(replacePattern, "$1" + newVersion);
        await fs_1.writeTextFile(file);
        return true;
    }
    return modified;
}
//# sourceMappingURL=update-files.js.map