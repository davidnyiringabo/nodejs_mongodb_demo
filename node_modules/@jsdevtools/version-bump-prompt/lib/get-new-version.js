"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getNewVersion = void 0;
const inquirer = require("inquirer");
const semver = require("semver");
const semver_1 = require("semver");
const release_type_1 = require("./release-type");
/**
 * Determines the new version number, possibly by prompting the user for it.
 */
async function getNewVersion(operation) {
    let { release } = operation.options;
    let { oldVersion } = operation.state;
    switch (release.type) {
        case "prompt":
            return promptForNewVersion(operation);
        case "version":
            let newSemVer = new semver_1.SemVer(release.version, true);
            return operation.update({
                newVersion: newSemVer.version,
            });
        default:
            return operation.update({
                release: release.type,
                newVersion: getNextVersion(oldVersion, release),
            });
    }
}
exports.getNewVersion = getNewVersion;
/**
 * Returns the next version number of the specified type.
 */
function getNextVersion(oldVersion, bump) {
    let oldSemVer = new semver_1.SemVer(oldVersion);
    let newSemVer = oldSemVer.inc(bump.type, bump.preid);
    if (release_type_1.isPrerelease(bump.type) &&
        newSemVer.prerelease.length === 2 &&
        newSemVer.prerelease[0] === bump.preid &&
        String(newSemVer.prerelease[1]) === "0") {
        // This is a special case when going from a non-prerelease version to a prerelease version.
        // SemVer sets the prerelease version to zero (e.g. "1.23.456" => "1.23.456-beta.0").
        // But the user probably expected it to be "1.23.456-beta.1" instead.
        // @ts-expect-error - TypeScript thinks this array is read-only
        newSemVer.prerelease[1] = "1";
        newSemVer.format();
    }
    return newSemVer.version;
}
/**
 * Returns the next version number for all release types.
 */
function getNextVersions(oldVersion, preid) {
    let next = {};
    for (let type of release_type_1.releaseTypes) {
        next[type] = getNextVersion(oldVersion, { type, preid });
    }
    return next;
}
/**
 * Prompts the user for the new version number.
 *
 * @returns - A tuple containing the new version number and the release type (if any)
 */
async function promptForNewVersion(operation) {
    let { oldVersion, oldVersionSource } = operation.state;
    let release = operation.options.release;
    let prompts = inquirer.createPromptModule(operation.options.interface);
    let next = getNextVersions(oldVersion, release.preid);
    let answers;
    answers = await prompts([
        {
            type: "list",
            name: "release",
            message: `\nThe current version in ${oldVersionSource} is ${oldVersion}\nHow would you like to bump it?`,
            default: "patch",
            pageSize: 10,
            choices: [
                { value: "major", name: `major (${next.major})` },
                { value: "minor", name: `minor (${next.minor})` },
                { value: "patch", name: `patch (${next.patch})` },
                { value: "premajor", name: `pre-release major (${next.premajor})` },
                { value: "preminor", name: `pre-release minor (${next.preminor})` },
                { value: "prepatch", name: `pre-release patch (${next.prepatch})` },
                { value: "prerelease", name: `pre-release (${next.prerelease})` },
                new inquirer.Separator(),
                { value: "none", name: `leave as-is (${oldVersion})` },
                { value: "custom", name: "custom..." },
            ]
        },
        {
            type: "input",
            name: "newVersion",
            message: "Enter the new version number:",
            default: oldVersion,
            when: (previousAnswer) => previousAnswer.release === "custom",
            filter: semver.clean,
            validate: (newVersion) => {
                return semver.valid(newVersion) ? true : "That's not a valid version number";
            },
        }
    ]);
    switch (answers.release) {
        case "none":
            return operation.update({ newVersion: oldVersion });
        case "custom":
            return operation.update({ newVersion: answers.newVersion });
        default:
            return operation.update({
                release: answers.release,
                newVersion: next[answers.release],
            });
    }
}
//# sourceMappingURL=get-new-version.js.map